<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>随机树（Canvas）</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #f6f1e6;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial;
      }
      #wrap {
        height: 100%;
        display: grid;
        place-items: center;
      }
      canvas {
        width: min(92vmin, 720px);
        height: min(92vmin, 720px);
        touch-action: none;
      }
      .btn {
        position: fixed;
        left: 16px;
        top: 16px;
        z-index: 10;
        border: 0;
        border-radius: 8px;
        padding: 8px 12px;
        background: #2e5a57;
        color: #eaf3f2;
        cursor: pointer;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
        font-weight: 600;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .hint {
        position: fixed;
        left: 16px;
        top: 52px;
        color: #58706c;
        font-size: 12px;
        opacity: 0.9;
      }
    </style>
  </head>
  <body>
    <button class="btn" id="newBtn">New Tree</button>
    <div class="hint">点击画面或按空格可刷新</div>
    <div id="wrap"><canvas id="c"></canvas></div>

    <script>
      (() => {
        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d");

        // ---------- 工具：可复现的随机数（seeded RNG） ----------
        function mulberry32(seed) {
          let a = seed >>> 0;
          return function () {
            a |= 0;
            a = (a + 0x6d2b79f5) | 0;
            let t = Math.imul(a ^ (a >>> 15), 1 | a);
            t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
            return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
          };
        }

        const TAU = Math.PI * 2;

        function resize() {
          // 按 CSS 大小设置像素，避免模糊
          const css = Math.min(window.innerWidth, window.innerHeight) * 0.92;
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          const size = Math.round(Math.min(css, 720));
          canvas.style.width = size + "px";
          canvas.style.height = size + "px";
          canvas.width = Math.round(size * dpr);
          canvas.height = Math.round(size * dpr);
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // ---------- 绘制：背景圆 + 草地弧形 ----------
        function drawBackground(w, h) {
          ctx.clearRect(0, 0, w, h);

          // 背景底色
          ctx.fillStyle = "#f6f1e6";
          ctx.fillRect(0, 0, w, h);

          const cx = w / 2,
            cy = h / 2;
          const R = Math.min(w, h) * 0.43;

          // 大圆（雾绿）
          ctx.beginPath();
          ctx.arc(cx, cy, R, 0, TAU);
          ctx.fillStyle = "#9fbab2";
          ctx.fill();

          // 草地：下半部深绿弧形
          // 草地：用圆弧而不是 ellipse
          ctx.save();

          // 限制在大圆内
          ctx.beginPath();
          ctx.arc(cx, cy, R, 0, Math.PI * 2);
          ctx.clip();

          // 画一个“更大的圆”的上半弧
          const grassR = R * 1.25;
          const grassCy = cy + R * 1.35;

          ctx.beginPath();
          ctx.arc(cx, grassCy, grassR, Math.PI, 0, false); // 上半弧
          ctx.lineTo(cx + grassR, h);
          ctx.lineTo(cx - grassR, h);
          ctx.closePath();

          ctx.fillStyle = "#234a45";
          ctx.fill();

          ctx.restore();

          return { cx, cy, R };
        }

        // ---------- 树：递归分枝（带弯曲） ----------
        function strokeBranch(x1, y1, x2, y2, thickness) {
          // 用二次贝塞尔做轻微弯曲，接近视频里的自然树枝
          const dx = x2 - x1,
            dy = y2 - y1;
          const mx = (x1 + x2) / 2,
            my = (y1 + y2) / 2;
          // 控制点偏移：垂直于枝干方向
          const len = Math.hypot(dx, dy) || 1;
          const nx = -dy / len,
            ny = dx / len;
          const bend = Math.min(18, len * 0.18) * (Math.random() * 2 - 1);
          const cx = mx + nx * bend;
          const cy = my + ny * bend;

          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.strokeStyle = "#3a2f28";
          ctx.lineWidth = thickness;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.quadraticCurveTo(cx, cy, x2, y2);
          ctx.stroke();
        }

        function drawBlossomCluster(x, y, rng, scale) {
          // 白色花朵团：许多小花瓣点 + 少量橙色点（视频里也有橙色）
          const n = Math.floor(20 + rng() * 22);
          for (let i = 0; i < n; i++) {
            const a = rng() * TAU;
            const rr = rng() ** 0.7 * (10 * scale);
            const px = x + Math.cos(a) * rr;
            const py = y + Math.sin(a) * rr;
            const s = (1.2 + rng() * 2.4) * scale;
            ctx.beginPath();
            ctx.arc(px, py, s, 0, TAU);
            ctx.fillStyle = "#f7f7f4";
            ctx.fill();
          }
          // 少量橙色点
          const m = Math.floor(1 + rng() * 3);
          for (let i = 0; i < m; i++) {
            const a = rng() * TAU;
            const rr = rng() ** 0.7 * (11 * scale);
            const px = x + Math.cos(a) * rr;
            const py = y + Math.sin(a) * rr;
            const s = (1.4 + rng() * 2.2) * scale;
            ctx.beginPath();
            ctx.arc(px, py, s, 0, TAU);
            ctx.fillStyle = "#e07c55";
            ctx.fill();
          }
        }

        function drawTree({ cx, cy, R }, seed) {
          const rng = mulberry32(seed);

          // 让所有“随机”都来自 rng（不要用 Math.random）
          // 但贝塞尔弯曲那里用了 Math.random；这里把它临时替换一下
          const _rand = Math.random;
          Math.random = rng;

          // 树的根基点
          const baseX = cx;
          const baseY = cy + R * 0.4;

          // 主干
          const trunkLen = R * (0.62 + rng() * 0.08);
          const trunkAngle = -Math.PI / 2 + (rng() * 0.28 - 0.14); // 略微倾斜

          // 递归参数
          const maxDepth = 7 + Math.floor(rng() * 2);
          const tips = []; // 记录末端用于开花

          function branch(x, y, len, angle, depth, thick) {
            const sway = (rng() * 0.3 - 0.15) * (1 - depth / (maxDepth + 1));
            const a2 = angle + sway;
            const x2 = x + Math.cos(a2) * len;
            const y2 = y + Math.sin(a2) * len;

            strokeBranch(x, y, x2, y2, thick);

            const nextThick = thick * (0.72 + rng() * 0.06);

            if (depth >= maxDepth || len < 10) {
              tips.push({ x: x2, y: y2, depth });
              return;
            }

            // 子枝数量：1~3
            const childCount = rng() < 0.2 ? 3 : rng() < 0.7 ? 2 : 1;
            for (let i = 0; i < childCount; i++) {
              const split = rng() * 0.75 + 0.25;
              const nextLen = len * (0.62 + rng() * 0.13) * split;
              const spread = 0.28 + rng() * 0.38;
              const dir = i === 0 ? -1 : i === 1 ? 1 : rng() < 0.5 ? -1 : 1;
              const nextAngle = a2 + dir * spread * (0.8 + rng() * 0.5);
              branch(x2, y2, nextLen, nextAngle, depth + 1, nextThick);
            }

            // 偶尔长出一条“回弯”的细枝（让轮廓更像视频）
            if (rng() < 0.12) {
              const nextLen = len * (0.42 + rng() * 0.14);
              const nextAngle =
                a2 + (rng() < 0.5 ? -1 : 1) * (0.85 + rng() * 0.35);
              branch(x2, y2, nextLen, nextAngle, depth + 1, nextThick * 0.75);
            }
          }

          // 主干起笔粗细
          branch(baseX, baseY, trunkLen, trunkAngle, 0, 6.2);

          // 开花：更多集中在树冠一侧（视频里是偏左一坨）
          // 1) 选择一侧重心
          let bias = rng() < 0.65 ? -1 : 1; // 偏左更常见
          let biasX = cx + bias * R * (0.14 + rng() * 0.1);

          // 2) 根据 tip 位置筛选/加权
          const blossoms = tips
            .map((t) => {
              const d = Math.hypot(t.x - biasX, t.y - (cy - R * 0.18));
              const w =
                (1 / (1 + d * 0.08)) * (0.6 + (t.depth / maxDepth) * 0.9);
              return { ...t, w };
            })
            .sort((a, b) => b.w - a.w);

          const clusterCount = Math.min(
            blossoms.length,
            10 + Math.floor(rng() * 10)
          );
          for (let i = 0; i < clusterCount; i++) {
            const t = blossoms[i];
            const jitter = R * 0.02;
            const x = t.x + (rng() * 2 - 1) * jitter;
            const y = t.y + (rng() * 2 - 1) * jitter;
            const scale = 0.9 + rng() * 0.7;
            drawBlossomCluster(x, y, rng, scale);
          }

          // 恢复 Math.random
          Math.random = _rand;
        }

        function render() {
          const w = canvas.clientWidth;
          const h = canvas.clientHeight;
          const bg = drawBackground(w, h);
          // 用时间戳做种子（可复现同一棵树：把 seed 固定即可）
          const seed = (Date.now() ^ (Math.random() * 1e9)) >>> 0;
          drawTree(bg, seed);
        }

        function init() {
          resize();
          render();
        }

        // 交互：按钮/点击/空格刷新
        document.getElementById("newBtn").addEventListener("click", render);
        canvas.addEventListener("pointerdown", render);
        window.addEventListener("keydown", (e) => {
          if (e.code === "Space") render();
        });
        window.addEventListener("resize", () => {
          resize();
          render();
        });

        init();
      })();
    </script>
  </body>
</html>
